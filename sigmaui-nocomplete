local output = ""
local captured = {}
local deobfuscated = {}

-- Luau bytecode opcodes
local opcodes = {
    [0] = "MOVE", [1] = "LOADK", [2] = "LOADBOOL", [3] = "LOADNIL", 
    [4] = "GETUPVAL", [5] = "GETGLOBAL", [6] = "GETTABLE", 
    [7] = "SETGLOBAL", [8] = "SETUPVAL", [9] = "SETTABLE",
    [10] = "NEWTABLE", [11] = "SELF", [12] = "ADD", [13] = "SUB",
    [14] = "MUL", [15] = "DIV", [16] = "MOD", [17] = "POW",
    [18] = "UNM", [19] = "NOT", [20] = "LEN", [21] = "CONCAT",
    [22] = "JMP", [23] = "EQ", [24] = "LT", [25] = "LE",
    [26] = "TEST", [27] = "TESTSET", [28] = "CALL", [29] = "TAILCALL",
    [30] = "RETURN", [31] = "FORLOOP", [32] = "FORPREP", [33] = "TFORLOOP",
    [34] = "SETLIST", [35] = "CLOSE", [36] = "CLOSURE", [37] = "VARARG"
}

local function write(file, data)
    if writefile then
        writefile(file, data)
        return true
    end
    warn("no write function available")
    return false
end

local function clip(text)
    if setclipboard then
        setclipboard(text)
        return true
    elseif toclipboard then
        toclipboard(text)
        return true
    end
    return false
end

local og_unpack = unpack or table.unpack
local og_load = loadstring

-- Enhanced table formatting with bytecode detection
local function fmt(tbl, indent)
    indent = indent or 0
    local spacing = string.rep("  ", indent)
    local result = "{"
    
    for index, value in pairs(tbl) do
        if type(value) == "table" then
            result = result .. string.format("\n%s[%s] = %s,", 
                spacing .. "  ", tostring(index), fmt(value, indent + 1))
        else
            local val = type(value) == "string" and string.format("%q", value) or tostring(value)
            result = result .. string.format("\n%s[%s] = %s,", 
                spacing .. "  ", tostring(index), val)
        end
    end
    
    result = result .. "\n" .. spacing .. "}"
    return result
end

-- Bytecode analysis functions
local function isBytecodeTable(tbl)
    if type(tbl) ~= "table" or #tbl == 0 then return false end
    
    -- Check if it has bytecode structure: nested tables with numbers
    for i, item in ipairs(tbl) do
        if type(item) == "table" then
            -- Check if first element is a number (opcode)
            if type(item[1]) == "number" then
                return true
            end
        end
    end
    return false
end

local function parseBytecodeInstruction(instr)
    if type(instr) ~= "table" then 
        return "INVALID: Not a table"
    end
    
    local opcode = instr[1] or 0
    local A = instr[2] or 0
    local B = instr[3]
    local C = instr[4]
    
    -- Handle different types for B and C
    local B_str = (type(B) == "table") and "table" or tostring(B)
    local C_str = (type(C) == "table") and "table" or tostring(C)
    
    local opname = opcodes[opcode] or "UNKNOWN_" .. tostring(opcode)
    
    return string.format("%s A=%s B=%s C=%s", opname, tostring(A), B_str, C_str)
end

local function extractConstants(bytecodeTable)
    local constants = {}
    
    for _, instr in ipairs(bytecodeTable) do
        if type(instr) == "table" then
            -- Check for string constants in positions 3 and 4
            for i = 3, 4 do
                if type(instr[i]) == "string" then
                    table.insert(constants, instr[i])
                end
            end
        end
    end
    
    return constants
end

local function analyzeBytecodePatterns(bytecodeTable)
    local patterns = {
        game_service_access = false,
        require_calls = false,
        string_operations = false,
        table_operations = false
    }
    
    local constants = extractConstants(bytecodeTable)
    
    for _, constant in ipairs(constants) do
        if constant:match("GetService") then
            patterns.game_service_access = true
        end
        if constant:match("require") then
            patterns.require_calls = true
        end
        if constant:match("game") then
            patterns.game_service_access = true
        end
        if constant:match("Module") then
            patterns.require_calls = true
        end
    end
    
    return patterns, constants
end

local function generateDeobfuscatedSource(bytecodeTable)
    if not isBytecodeTable(bytecodeTable) then
        return "-- Not a bytecode table\n" .. fmt(bytecodeTable)
    end
    
    local patterns, constants = analyzeBytecodePatterns(bytecodeTable)
    
    local source = "-- Deobfuscated Bytecode Analysis\n"
    source = source .. "-- Generated: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n"
    source = source .. "-- Total Instructions: " .. #bytecodeTable .. "\n\n"
    
    -- Add common game references based on patterns
    if patterns.game_service_access then
        source = source .. "-- Game Services Detected\n"
        source = source .. "local game = game\n"
        source = source .. "local Players = game:GetService(\"Players\")\n"
        source = source .. "local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n"
        source = source .. "local RunService = game:GetService(\"RunService\")\n\n"
    end
    
    if patterns.require_calls then
        source = source .. "-- Module System Detected\n"
    end
    
    -- Add extracted constants
    if #constants > 0 then
        source = source .. "-- Extracted Constants (" .. #constants .. " found):\n"
        for i, constant in ipairs(constants) do
            if #constant < 50 then  -- Avoid huge strings
                source = source .. string.format('-- [%d] "%s"\n', i, constant:gsub('"', '\\"'))
            else
                source = source .. string.format('-- [%d] [long string: %d characters]\n', i, #constant)
            end
        end
        source = source .. "\n"
    end
    
    -- Add bytecode instructions as comments (limited to first 50 to avoid huge files)
    source = source .. "-- Bytecode Instructions (showing first 50):\n"
    local maxInstructions = math.min(50, #bytecodeTable)
    for i = 1, maxInstructions do
        local instr = bytecodeTable[i]
        if type(instr) == "table" then
            local instructionStr = parseBytecodeInstruction(instr)
            source = source .. string.format("-- [%03d] %s\n", i, instructionStr)
        end
    end
    
    if #bytecodeTable > 50 then
        source = source .. string.format("-- ... and %d more instructions\n", #bytecodeTable - 50)
    end
    
    return source
end

-- Enhanced unpack hook with deobfuscation
function unpack(...)
    local args = {...}
    local t = args[1]
    
    if type(t) == "table" then
        local formatted = fmt(t)
        output = output .. "\n" .. string.rep("-", 40) .. "\n"
        output = output .. "CAPTURED TABLE (size: " .. #t .. ")\n"
        output = output .. string.rep("-", 40) .. "\n"
        output = output .. formatted .. "\n"
        
        table.insert(captured, t)
        print("[*] captured table, size:", #t)
        
        -- Deobfuscate bytecode tables
        if isBytecodeTable(t) then
            print("[*] bytecode table detected, deobfuscating...")
            local deobfuscatedSource = generateDeobfuscatedSource(t)
            table.insert(deobfuscated, deobfuscatedSource)
            output = output .. "\n" .. string.rep("=", 50) .. "\n"
            output = output .. "DEOBFUSCATED ANALYSIS\n"
            output = output .. string.rep("=", 50) .. "\n"
            output = output .. deobfuscatedSource .. "\n"
        else
            print("[*] regular table, not bytecode")
        end
    end
    
    return og_unpack(...)
end

-- Enhanced loadstring hook
loadstring = function(code, ...)
    if type(code) == "string" then
        if code:find("return function") and code:find("local d=") then
            print("[*] moonsec v3 detected")
            output = output .. "\n" .. string.rep("=", 50) .. "\n"
            output = output .. "MOONSEC V3 DETECTED\n"
            output = output .. string.rep("=", 50) .. "\n"
            output = output .. "Code length: " .. #code .. " characters\n"
            output = output .. string.rep("=", 50) .. "\n"
        end
        
        -- Detect other obfuscators
        if code:find("getfenv") and code:find("table.concat") then
            print("[*] possible other obfuscator detected")
        end
    end
    return og_load(code, ...)
end

local function save()
    local file = "dump_" .. os.time() .. ".txt"
    local deobfuscatedFile = "deobfuscated_" .. os.time() .. ".lua"
    
    -- Combine all deobfuscated sources
    local allDeobfuscated = ""
    if #deobfuscated > 0 then
        allDeobfuscated = "-- DEOBFUSCATED SOURCES\n"
        allDeobfuscated = allDeobfuscated .. string.rep("=", 50) .. "\n\n"
        for i, source in ipairs(deobfuscated) do
            allDeobfuscated = allDeobfuscated .. string.format("-- File %d/%d\n", i, #deobfuscated)
            allDeobfuscated = allDeobfuscated .. source
            allDeobfuscated = allDeobfuscated .. "\n" .. string.rep("-", 40) .. "\n\n"
        end
    else
        allDeobfuscated = "-- No bytecode tables were deobfuscated\n"
        allDeobfuscated = allDeobfuscated .. "-- Only regular tables were captured\n"
    end
    
    local result = string.format([[
========================================
RAT'S DUMP & DEOBFUSCATION RESULTS
========================================
Timestamp: %s
Tables Captured: %d
Bytecode Tables Deobfuscated: %d

=== RAW CAPTURED DATA ===
%s
]], os.date("%Y-%m-%d %H:%M:%S"), #captured, #deobfuscated, output)
    
    if write(file, result) then
        print("[+] saved dump:", file)
    end
    
    if write(deobfuscatedFile, allDeobfuscated) then
        print("[+] saved deobfuscated:", deobfuscatedFile)
    end
    
    if clip(allDeobfuscated) then
        print("[+] deobfuscated code copied to clipboard")
    end
    
    print("[+] complete - tables:", #captured, "deobfuscated:", #deobfuscated)
end

-- Auto-save when player leaves (for Roblox)
if game then
    game:GetService("Players").LocalPlayer:GetPropertyChangedSignal("Parent"):Connect(function()
        print("[*] player leaving, saving...")
        save()
    end)
    
    -- Manual save with F9
    game:GetService("UserInputService").InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.F9 then
            print("[*] manual save triggered")
            save()
        end
    end)
end

print("[*] advanced deobfuscator ready")
print("[*] execute obfuscated script")
print("[*] features: bytecode analysis, constant extraction, pattern detection")

-- Better monitoring with periodic status
task.spawn(function()
    local checks = 0
    while true do
        task.wait(2)
        checks = checks + 1
        if #captured > 0 or #deobfuscated > 0 then
            print(string.format("[*] status: %d tables, %d deobfuscated", #captured, #deobfuscated))
        elseif checks % 5 == 0 then
            print("[*] monitoring... no data captured yet")
        end
    end
end)

-- Auto-save after 10 seconds if we have data
task.spawn(function()
    task.wait(10)
    if #captured > 0 then
        print("[*] auto-saving after 10 seconds")
        save()
    end
end)
