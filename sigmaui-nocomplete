local output = ""
local captured = {}
local deobfuscated = {}

-- Luau bytecode opcodes
local opcodes = {
    [0] = "MOVE", [1] = "LOADK", [2] = "LOADBOOL", [3] = "LOADNIL", 
    [4] = "GETUPVAL", [5] = "GETGLOBAL", [6] = "GETTABLE", 
    [7] = "SETGLOBAL", [8] = "SETUPVAL", [9] = "SETTABLE",
    [10] = "NEWTABLE", [11] = "SELF", [12] = "ADD", [13] = "SUB",
    [14] = "MUL", [15] = "DIV", [16] = "MOD", [17] = "POW",
    [18] = "UNM", [19] = "NOT", [20] = "LEN", [21] = "CONCAT",
    [22] = "JMP", [23] = "EQ", [24] = "LT", [25] = "LE",
    [26] = "TEST", [27] = "TESTSET", [28] = "CALL", [29] = "TAILCALL",
    [30] = "RETURN", [31] = "FORLOOP", [32] = "FORPREP", [33] = "TFORLOOP",
    [34] = "SETLIST", [35] = "CLOSE", [36] = "CLOSURE", [37] = "VARARG"
}

local function write(file, data)
    if writefile then
        writefile(file, data)
        return true
    end
    warn("no write function available")
    return false
end

local function clip(text)
    if setclipboard then
        setclipboard(text)
        return true
    elseif toclipboard then
        toclipboard(text)
        return true
    end
    return false
end

local og_unpack = unpack or table.unpack
local og_load = loadstring

-- Enhanced table formatting with bytecode detection
local function fmt(tbl, indent)
    indent = indent or 0
    local spacing = string.rep("  ", indent)
    local result = "{"
    
    for index, value in pairs(tbl) do
        if type(value) == "table" then
            result = result .. string.format("\n%s[%s] = %s,", 
                spacing .. "  ", tostring(index), fmt(value, indent + 1))
        else
            local val = type(value) == "string" and string.format("%q", value) or tostring(value)
            result = result .. string.format("\n%s[%s] = %s,", 
                spacing .. "  ", tostring(index), val)
        end
    end
    
    result = result .. "\n" .. spacing .. "}"
    return result
end

-- Bytecode analysis functions
local function isBytecodeTable(tbl)
    if type(tbl) ~= "table" or #tbl == 0 then return false end
    
    -- Check if it has bytecode structure: {opcode, A, B, C}
    local first = tbl[1]
    if type(first) == "table" and (first[1] or first[2]) then
        for i, instr in ipairs(tbl) do
            if type(instr) == "table" and (instr[1] ~= nil or instr[2] ~= nil) then
                -- Likely bytecode instruction
                return true
            end
        end
    end
    return false
end

local function parseBytecodeInstruction(instr)
    if type(instr) ~= "table" or #instr < 2 then return "INVALID" end
    
    local opcode = instr[1] or 0
    local A = instr[2] or 0
    local B = instr[3] or 0
    local C = instr[4] or 0
    
    local opname = opcodes[opcode] or "UNKNOWN_" .. tostring(opcode)
    
    return string.format("%s A=%d B=%s C=%s", opname, A, tostring(B), tostring(C))
end

local function extractConstants(bytecodeTable)
    local constants = {}
    local strings = {}
    
    for _, instr in ipairs(bytecodeTable) do
        if type(instr) == "table" then
            -- Check for string constants
            if type(instr[3]) == "string" then
                table.insert(strings, instr[3])
            end
            if type(instr[4]) == "string" then
                table.insert(strings, instr[4])
            end
        end
    end
    
    return strings
end

local function analyzeBytecodePatterns(bytecodeTable)
    local patterns = {
        game_service_access = false,
        require_calls = false,
        string_operations = false,
        table_operations = false
    }
    
    local constants = extractConstants(bytecodeTable)
    
    for _, constant in ipairs(constants) do
        if constant:match("GetService") then
            patterns.game_service_access = true
        end
        if constant:match("require") then
            patterns.require_calls = true
        end
        if constant:match("game") then
            patterns.game_service_access = true
        end
    end
    
    return patterns
end

local function generateDeobfuscatedSource(bytecodeTable)
    if not isBytecodeTable(bytecodeTable) then
        return "-- Not a bytecode table\n"
    end
    
    local constants = extractConstants(bytecodeTable)
    local patterns = analyzeBytecodePatterns(bytecodeTable)
    
    local source = "-- Deobfuscated Bytecode Analysis\n"
    source = source .. "-- Generated: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n\n"
    
    -- Add common game references
    if patterns.game_service_access then
        source = source .. "local game = game\n"
        source = source .. "local Players = game:GetService(\"Players\")\n"
        source = source .. "local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n"
        source = source .. "local RunService = game:GetService(\"RunService\")\n\n"
    end
    
    -- Add extracted constants as potential variables
    if #constants > 0 then
        source = source .. "-- Extracted Constants:\n"
        for i, constant in ipairs(constants) do
            if #constant < 100 then  -- Avoid huge strings
                source = source .. string.format('-- constant_%d = "%s"\n', i, constant:gsub('"', '\\"'))
            end
        end
        source = source .. "\n"
    end
    
    -- Add bytecode instructions as comments
    source = source .. "-- Bytecode Instructions:\n"
    for i, instr in ipairs(bytecodeTable) do
        if type(instr) == "table" then
            local instructionStr = parseBytecodeInstruction(instr)
            source = source .. string.format("-- [%d] %s\n", i, instructionStr)
        end
    end
    
    -- Try to reconstruct simple logic
    source = source .. "\n-- Reconstructed Logic:\n"
    for _, constant in ipairs(constants) do
        if constant == "LocalPlayer" then
            source = source .. "local player = Players.LocalPlayer\n"
        elseif constant == "Character" then
            source = source .. "local character = player.Character or player.CharacterAdded:Wait()\n"
        elseif constant == "Humanoid" then
            source = source .. "local humanoid = character:WaitForChild(\"Humanoid\")\n"
        elseif constant:match("^Modules%.") then
            source = source .. string.format('local module = require("%s")\n', constant)
        end
    end
    
    return source
end

-- Enhanced unpack hook with deobfuscation
function unpack(...)
    local args = {...}
    local t = args[1]
    
    if type(t) == "table" then
        local formatted = fmt(t)
        output = output .. "\n" .. formatted .. "\n\n"
        table.insert(captured, t)
        print("[*] captured table, size:", #t)
        
        -- Deobfuscate bytecode tables
        if isBytecodeTable(t) then
            print("[*] bytecode table detected, deobfuscating...")
            local deobfuscatedSource = generateDeobfuscatedSource(t)
            table.insert(deobfuscated, deobfuscatedSource)
            output = output .. "\n" .. deobfuscatedSource .. "\n"
        end
    end
    
    return og_unpack(...)
end

-- Enhanced loadstring hook
loadstring = function(code, ...)
    if type(code) == "string" then
        if code:find("return function") and code:find("local d=") then
            print("[*] moonsec v3 detected")
            output = output .. "\n" .. string.rep("=", 50) .. "\n"
            output = output .. "MOONSEC V3 DETECTED\n"
            output = output .. string.rep("=", 50) .. "\n"
            output = output .. code .. "\n\n"
        end
        
        -- Detect other obfuscators
        if code:find("getfenv") and code:find("table.concat") then
            print("[*] possible obfuscated script detected")
        end
    end
    return og_load(code, ...)
end

local function save()
    local file = "dump_" .. os.time() .. ".txt"
    local deobfuscatedFile = "deobfuscated_" .. os.time() .. ".lua"
    
    -- Combine all deobfuscated sources
    local allDeobfuscated = table.concat(deobfuscated, "\n" .. string.rep("=", 60) .. "\n")
    
    local result = string.format([[
========================================
RAT'S DUMP & DEOBFUSCATION RESULTS
========================================
Captured: %s
Tables: %d
Deobfuscated Files: %d

=== CAPTURED TABLES ===
%s

=== DEOBFUSCATED SOURCES ===
%s
========================================
]], os.date("%Y-%m-%d %H:%M:%S"), #captured, #deobfuscated, output, allDeobfuscated)
    
    if write(file, result) then
        print("[+] saved dump:", file)
    end
    
    if write(deobfuscatedFile, allDeobfuscated) then
        print("[+] saved deobfuscated:", deobfuscatedFile)
    end
    
    if clip(result) then
        print("[+] copied to clipboard")
    end
    print("[+] complete, tables:", #captured, "deobfuscated:", #deobfuscated)
end

-- Auto-save when player leaves (for Roblox)
if game then
    game:GetService("Players").LocalPlayer:GetPropertyChangedSignal("Parent"):Connect(save)
    
    -- Manual save with F9
    game:GetService("UserInputService").InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.F9 then
            save()
        end
    end)
end

print("[*] advanced deobfuscator ready")
print("[*] execute obfuscated script")
print("[*] features: bytecode analysis, constant extraction, pattern detection")

task.spawn(function()
    task.wait(5)
    if #captured > 0 or #deobfuscated > 0 then
        save()
    else
        print("[*] no data captured yet, still monitoring...")
    end
end)
