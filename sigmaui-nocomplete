local output = ""
local captured = {}
local deobfuscated = {}

-- Luau bytecode opcodes
local opcodes = {
    [0] = "MOVE", [1] = "LOADK", [2] = "LOADBOOL", [3] = "LOADNIL", 
    [4] = "GETUPVAL", [5] = "GETGLOBAL", [6] = "GETTABLE", 
    [7] = "SETGLOBAL", [8] = "SETUPVAL", [9] = "SETTABLE",
    [10] = "NEWTABLE", [11] = "SELF", [12] = "ADD", [13] = "SUB",
    [14] = "MUL", [15] = "DIV", [16] = "MOD", [17] = "POW",
    [18] = "UNM", [19] = "NOT", [20] = "LEN", [21] = "CONCAT",
    [22] = "JMP", [23] = "EQ", [24] = "LT", [25] = "LE",
    [26] = "TEST", [27] = "TESTSET", [28] = "CALL", [29] = "TAILCALL",
    [30] = "RETURN", [31] = "FORLOOP", [32] = "FORPREP", [33] = "TFORLOOP",
    [34] = "SETLIST", [35] = "CLOSE", [36] = "CLOSURE", [37] = "VARARG"
}

local function write(file, data)
    if writefile then
        writefile(file, data)
        return true
    end
    warn("no write function available")
    return false
end

local function clip(text)
    if setclipboard then
        setclipboard(text)
        return true
    elseif toclipboard then
        toclipboard(text)
        return true
    end
    return false
end

local og_unpack = unpack or table.unpack
local og_load = loadstring

-- Simple table formatting
local function fmt(tbl, indent)
    indent = indent or 0
    local spacing = string.rep("  ", indent)
    local result = "{"
    
    for index, value in pairs(tbl) do
        if type(value) == "table" then
            result = result .. string.format("\n%s[%s] = %s,", 
                spacing .. "  ", tostring(index), fmt(value, indent + 1))
        else
            local val = type(value) == "string" and string.format("%q", value) or tostring(value)
            result = result .. string.format("\n%s[%s] = %s,", 
                spacing .. "  ", tostring(index), val)
        end
    end
    
    result = result .. "\n" .. spacing .. "}"
    return result
end

-- MUCH SIMPLER bytecode detection
local function isBytecodeTable(tbl)
    if type(tbl) ~= "table" then return false end
    
    -- Check if it's a nested table structure (common in obfuscators)
    local nestedCount = 0
    local totalItems = 0
    
    for _, item in pairs(tbl) do
        totalItems = totalItems + 1
        if type(item) == "table" then
            nestedCount = nestedCount + 1
            -- Check if nested table has numbers (potential bytecode)
            for k, v in pairs(item) do
                if type(k) == "number" and type(v) == "number" then
                    return true
                end
            end
        end
    end
    
    -- If most items are nested tables, likely bytecode
    if totalItems > 0 and (nestedCount / totalItems) > 0.5 then
        return true
    end
    
    return false
end

local function parseBytecodeInstruction(instr)
    if type(instr) ~= "table" then 
        return "INVALID: Not a table"
    end
    
    local parts = {}
    for i = 1, 4 do
        local val = instr[i]
        if val == nil then
            table.insert(parts, "nil")
        else
            table.insert(parts, tostring(val))
        end
    end
    
    return "[" .. table.concat(parts, ", ") .. "]"
end

local function extractConstants(bytecodeTable)
    local constants = {}
    
    for _, instr in pairs(bytecodeTable) do
        if type(instr) == "table" then
            -- Look for strings in any position
            for i = 1, #instr do
                local value = instr[i]
                if type(value) == "string" then
                    table.insert(constants, value)
                end
            end
        end
    end
    
    return constants
end

local function analyzeTable(tbl)
    local analysis = {
        type = "unknown",
        size = #tbl,
        nestedTables = 0,
        stringsFound = {},
        numbersFound = 0
    }
    
    for _, item in pairs(tbl) do
        if type(item) == "table" then
            analysis.nestedTables = analysis.nestedTables + 1
        elseif type(item) == "string" then
            table.insert(analysis.stringsFound, item)
        elseif type(item) == "number" then
            analysis.numbersFound = analysis.numbersFound + 1
        end
    end
    
    -- Determine type
    if analysis.nestedTables > analysis.size * 0.3 then
        analysis.type = "likely_bytecode"
    elseif #analysis.stringsFound > 0 then
        analysis.type = "string_data"
    elseif analysis.numbersFound > 0 then
        analysis.type = "numeric_data"
    else
        analysis.type = "mixed_data"
    end
    
    return analysis
end

local function generateDeobfuscatedSource(tbl, tableIndex)
    local analysis = analyzeTable(tbl)
    local constants = extractConstants(tbl)
    
    local source = string.format("-- Table #%d Analysis\n", tableIndex)
    source = source .. string.format("-- Type: %s\n", analysis.type)
    source = source .. string.format("-- Size: %d, Nested: %d, Numbers: %d\n", 
        analysis.size, analysis.nestedTables, analysis.numbersFound)
    
    -- Add extracted strings/constants
    if #constants > 0 then
        source = source .. string.format("-- Extracted Strings (%d found):\n", #constants)
        for i, constant in ipairs(constants) do
            if #constant < 100 then
                source = source .. string.format('-- [%d] "%s"\n', i, constant:gsub('"', '\\"'))
            else
                source = source .. string.format('-- [%d] [long string: %d chars]\n', i, #constant)
            end
        end
    end
    
    -- Try to identify common patterns in the strings
    local gameRefs = {}
    local functionRefs = {}
    
    for _, constant in ipairs(constants) do
        if constant:match("game") or constant:match("GetService") then
            table.insert(gameRefs, constant)
        elseif constant:match("function") or constant:match("local") then
            table.insert(functionRefs, constant)
        end
    end
    
    if #gameRefs > 0 then
        source = source .. "-- Game References Found:\n"
        for _, ref in ipairs(gameRefs) do
            source = source .. string.format('--   "%s"\n', ref)
        end
    end
    
    -- Show first few instructions if it looks like bytecode
    if analysis.type == "likely_bytecode" then
        source = source .. "-- First 10 Instructions:\n"
        local count = 0
        for i, instr in pairs(tbl) do
            if type(instr) == "table" then
                source = source .. string.format("-- [%d] %s\n", i, parseBytecodeInstruction(instr))
                count = count + 1
                if count >= 10 then break end
            end
        end
    end
    
    return source
end

-- Enhanced unpack hook - process EVERY table
function unpack(...)
    local args = {...}
    local t = args[1]
    
    if type(t) == "table" then
        local tableIndex = #captured + 1
        table.insert(captured, t)
        
        print(string.format("[*] captured table #%d, size: %d", tableIndex, #t))
        
        -- Analyze EVERY table, not just "bytecode" ones
        local analysis = analyzeTable(t)
        print(string.format("[*] table #%d type: %s (nested: %d, strings: %d)", 
            tableIndex, analysis.type, analysis.nestedTables, #analysis.stringsFound))
        
        -- Generate analysis for this table
        local deobfuscatedSource = generateDeobfuscatedSource(t, tableIndex)
        table.insert(deobfuscated, deobfuscatedSource)
        
        -- Add to output
        output = output .. "\n" .. string.rep("=", 50) .. "\n"
        output = output .. string.format("TABLE #%d ANALYSIS\n", tableIndex)
        output = output .. string.rep("=", 50) .. "\n"
        output = output .. deobfuscatedSource .. "\n"
        
        -- Show raw data for small tables
        if #t <= 20 then
            output = output .. "-- Raw Data:\n"
            output = output .. fmt(t) .. "\n"
        else
            output = output .. string.format("-- [Table too large to display: %d items]\n", #t)
        end
    end
    
    return og_unpack(...)
end

-- Enhanced loadstring hook
loadstring = function(code, ...)
    if type(code) == "string" then
        output = output .. "\n" .. string.rep("=", 50) .. "\n"
        output = output .. "LOADSTRING CALLED\n"
        output = output .. string.rep("=", 50) .. "\n"
        output = output .. "Code length: " .. #code .. " characters\n"
        
        if code:find("return function") and code:find("local d=") then
            output = output .. "DETECTED: Moonsec V3\n"
        elseif code:find("getfenv") and code:find("table.concat") then
            output = output .. "DETECTED: Possible obfuscator\n"
        end
        
        -- Show first 200 chars of code
        local preview = code:sub(1, 200)
        output = output .. "Preview: " .. preview .. "\n"
        if #code > 200 then
            output = output .. "... [truncated]\n"
        end
    end
    return og_load(code, ...)
end

local function save()
    local file = "dump_" .. os.time() .. ".txt"
    local deobfuscatedFile = "deobfuscated_" .. os.time() .. ".lua"
    
    -- Combine all deobfuscated sources
    local allDeobfuscated = ""
    if #deobfuscated > 0 then
        allDeobfuscated = "-- DEOBFUSCATED ANALYSIS RESULTS\n"
        allDeobfuscated = allDeobfuscated .. string.rep("=", 50) .. "\n\n"
        for i, source in ipairs(deobfuscated) do
            allDeobfuscated = allDeobfuscated .. source
            allDeobfuscated = allDeobfuscated .. "\n" .. string.rep("-", 40) .. "\n\n"
        end
    else
        allDeobfuscated = "-- No tables were captured\n"
    end
    
    local result = string.format([[
RAT'S DEOBFUSCATOR RESULTS
Timestamp: %s
Total Tables Captured: %d

=== ANALYSIS RESULTS ===
%s
]], os.date("%Y-%m-%d %H:%M:%S"), #captured, allDeobfuscated)
    
    if write(file, result) then
        print("[+] saved dump:", file)
    end
    
    if write(deobfuscatedFile, allDeobfuscated) then
        print("[+] saved deobfuscated:", deobfuscatedFile)
    end
    
    if clip(allDeobfuscated) then
        print("[+] analysis copied to clipboard")
    end
    
    print("[+] complete - tables analyzed:", #captured)
end

-- Auto-save when player leaves (for Roblox)
if game then
    game:GetService("Players").LocalPlayer:GetPropertyChangedSignal("Parent"):Connect(function()
        print("[*] player leaving, saving...")
        save()
    end)
    
    -- Manual save with F9
    game:GetService("UserInputService").InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.F9 then
            print("[*] manual save triggered")
            save()
        end
    end)
end

print("[*] universal deobfuscator ready")
print("[*] will analyze ALL captured tables")
print("[*] execute obfuscated script")

-- Better monitoring
task.spawn(function()
    while true do
        task.wait(3)
        if #captured > 0 then
            print(string.format("[*] status: %d tables captured and analyzed", #captured))
        else
            print("[*] monitoring... waiting for tables")
        end
    end
end)

-- Auto-save after 8 seconds
task.spawn(function()
    task.wait(8)
    if #captured > 0 then
        print("[*] auto-saving captured data")
        save()
    end
end)
